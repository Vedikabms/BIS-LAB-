# -*- coding: utf-8 -*-
"""Neural  Network Cuckoo search.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bJpTDS3Ox5DORFmBjbqiD83Z2a2pn46U
"""

import numpy as np
from scipy.special import gamma

# Activation
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

# Forward Pass
def forward_pass(params, X, input_size, hidden_size, output_size):
    i, h, o = input_size, hidden_size, output_size
    W1 = params[:i*h].reshape(i, h)
    b1 = params[i*h:i*h+h].reshape(1, h)
    W2 = params[i*h+h:i*h+h+h*o].reshape(h, o)
    b2 = params[-o:].reshape(1, o)

    hidden = sigmoid(X @ W1 + b1)
    output = sigmoid(hidden @ W2 + b2)
    return output

# Loss Function (MSE)
def fitness(params, X, y, input_size, hidden_size, output_size):
    pred = forward_pass(params, X, input_size, hidden_size, output_size)
    return np.mean((y - pred) ** 2)

# Levy Flight
def levy_flight(size, Lambda=1.5):
    sigma = (gamma(1+Lambda) * np.sin(np.pi*Lambda/2) /
             (gamma((1+Lambda)/2) * Lambda * 2**((Lambda-1)/2))) ** (1/Lambda)
    u = np.random.normal(0, sigma, size)
    v = np.random.normal(0, 1, size)
    return u / np.abs(v)**(1/Lambda)

# Cuckoo Search
def cuckoo_search(X, y, input_size, hidden_size, output_size,
                  nests=20, iterations=500, Pa=0.25, alpha=0.01):
    total_params = input_size*hidden_size + hidden_size + hidden_size*output_size + output_size
    nest = np.random.uniform(-1, 1, (nests, total_params))
    scores = np.array([fitness(n, X, y, input_size, hidden_size, output_size) for n in nest])

    best = nest[np.argmin(scores)]
    best_score = np.min(scores)

    for _ in range(iterations):
        for i in range(nests):
            new = nest[i] + alpha * levy_flight(total_params) * (nest[i] - np.random.randn(total_params))
            new_score = fitness(new, X, y, input_size, hidden_size, output_size)
            if new_score < scores[i]:
                nest[i] = new
                scores[i] = new_score
                if new_score < best_score:
                    best = new
                    best_score = new_score

        for i in range(nests):
            if np.random.rand() < Pa:
                nest[i] = np.random.uniform(-1, 1, total_params)
                scores[i] = fitness(nest[i], X, y, input_size, hidden_size, output_size)

    return best, best_score

# ----------------- Training Data (example) ----------------- #
X = np.array([[0.1, 0.5], [0.4, 0.9], [0.7, 0.2], [0.9, 0.6]])
y = np.array([[0.3], [0.7], [0.6], [0.9]])

input_size = X.shape[1]
hidden_size = 4
output_size = y.shape[1]

best_params, error = cuckoo_search(X, y, input_size, hidden_size, output_size,
                                   nests=25, iterations=1000, Pa=0.25, alpha=0.01)

print("Training complete. Best MSE:", error)

print("\nPredictions on training data:")
preds = forward_pass(best_params, X, input_size, hidden_size, output_size)
for i, p in enumerate(preds):
    print(f"Input: {X[i]} => Predicted: {p[0]:.4f}, Target: {y[i][0]}")

# ----------------- USER INPUT ----------------- #
print("\nEnter your own input values to test the network. Type 'exit' to quit.")
while True:
    user_input = input(f"Enter {input_size} values separated by space: ")
    if user_input.strip().lower() == 'exit':
        print("Exiting.")
        break
    try:
        values = list(map(float, user_input.strip().split()))
        if len(values) != input_size:
            print(f"Please enter exactly {input_size} numbers.")
            continue
        user_array = np.array([values])
        output = forward_pass(best_params, user_array, input_size, hidden_size, output_size)
        print(f"Output: {output[0][0]:.4f}")
    except:
        print("Invalid input. Please try again.")