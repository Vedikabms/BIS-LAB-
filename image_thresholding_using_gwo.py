# -*- coding: utf-8 -*-
"""Image processing using gwo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aBst3dAwwtL2rGId3-G-dy2c1QjF0PVv
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread('coin', cv2.IMREAD_GRAYSCALE)

if img is None:
    raise ValueError("Image not found. Make sure the file exists in your folder or uploaded correctly.")

plt.imshow(img, cmap='gray')
plt.title("Original Image")
plt.axis('off')
plt.show()

# ==============================
# 2. Fitness function (Otsu's method)
# ==============================
def otsu_fitness(threshold, image):
    threshold = int(threshold)
    hist, bins = np.histogram(image.ravel(), 256, [0, 256])
    total = image.size
    sum_total = np.dot(np.arange(256), hist)

    sumB, wB, wF, max_var = 0, 0, 0, 0

    for t in range(threshold):
        wB += hist[t]
        if wB == 0:
            continue
        wF = total - wB
        if wF == 0:
            break
        sumB += t * hist[t]
        mB = sumB / wB
        mF = (sum_total - sumB) / wF
        var_between = wB * wF * (mB - mF)**2
        if var_between > max_var:
            max_var = var_between
    return max_var  # maximize this

# ==============================
# 3. Grey Wolf Optimization
# ==============================
def GWO(fitness_func, image, pop_size=10, max_iter=20, lb=0, ub=255):
    dim = 1  # only one variable: threshold
    Alpha, Beta, Delta = np.inf, np.inf, np.inf
    Alpha_pos, Beta_pos, Delta_pos = 0, 0, 0

    # Initialize population (wolves)
    Positions = np.random.randint(lb, ub, (pop_size, dim))

    # Main loop
    for iter in range(max_iter):
        for i in range(pop_size):
            fitness = -fitness_func(Positions[i], image)  # negative because we maximize
            if fitness < Alpha:
                Alpha, Alpha_pos = fitness, Positions[i].copy()
            elif fitness < Beta and fitness > Alpha:
                Beta, Beta_pos = fitness, Positions[i].copy()
            elif fitness < Delta and fitness > Beta:
                Delta, Delta_pos = fitness, Positions[i].copy()

        a = 2 - iter * (2 / max_iter)  # decreases linearly from 2 to 0

        for i in range(pop_size):
            for j in range(dim):
                r1, r2 = np.random.rand(), np.random.rand()
                A1, C1 = 2 * a * r1 - a, 2 * r2
                D_alpha = abs(C1 * Alpha_pos[j] - Positions[i][j])
                X1 = Alpha_pos[j] - A1 * D_alpha

                r1, r2 = np.random.rand(), np.random.rand()
                A2, C2 = 2 * a * r1 - a, 2 * r2
                D_beta = abs(C2 * Beta_pos[j] - Positions[i][j])
                X2 = Beta_pos[j] - A2 * D_beta

                r1, r2 = np.random.rand(), np.random.rand()
                A3, C3 = 2 * a * r1 - a, 2 * r2
                D_delta = abs(C3 * Delta_pos[j] - Positions[i][j])
                X3 = Delta_pos[j] - A3 * D_delta

                Positions[i][j] = np.clip((X1 + X2 + X3) / 3, lb, ub)

    best_threshold = int(Alpha_pos[0])
    return best_threshold

# ==============================
# 4. Run GWO and apply threshold
# ==============================
best_T = GWO(otsu_fitness, img, pop_size=15, max_iter=30)
print(f"Best Threshold Found by GWO: {best_T}")

_, result = cv2.threshold(img, best_T, 255, cv2.THRESH_BINARY)

plt.subplot(1, 2, 1)
plt.imshow(img, cmap='gray')
plt.title('Original Image')

plt.subplot(1, 2, 2)
plt.imshow(result, cmap='gray')
plt.title(f'Segmented Image (T={best_T})')
plt.show()
