# -*- coding: utf-8 -*-
"""Optimization using PCA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CTwkxepb71QF6TOxyznxE3qPJiaFxuEz
"""

import numpy as np

# --- Step 1: Define Problem ---
def f(x):
    """Objective function to minimize."""
    return x**2 - 4*x + 4  # Minimum at x = 2

# --- Step 2: Initialize Parameters ---
grid_size = (10, 10)         # 10x10 grid
num_iterations = 100
search_space = (-10, 10)

# --- Step 3: Initialize Population ---
grid = np.random.uniform(search_space[0], search_space[1], grid_size)

# Helper to get 3x3 neighborhood indices
def get_neighbors(grid, i, j):
    rows, cols = grid.shape
    neighbors = []
    for x in range(i - 1, i + 2):
        for y in range(j - 1, j + 2):
            if 0 <= x < rows and 0 <= y < cols:
                neighbors.append((x, y))
    return neighbors

# --- Step 4â€“6: Iterate Optimization ---
best_val = None
best_fit = float('inf')

for iteration in range(num_iterations):
    new_grid = np.copy(grid)
    fitness_grid = f(grid)

    # Track best cell
    current_best = np.min(fitness_grid)
    if current_best < best_fit:
        best_fit = current_best
        best_val = grid[np.unravel_index(np.argmin(fitness_grid), grid.shape)]

    # --- Step 5: Update States ---
    for i in range(grid_size[0]):
        for j in range(grid_size[1]):
            neighbors = get_neighbors(grid, i, j)
            neighbor_values = [grid[x, y] for x, y in neighbors]
            neighbor_fitness = [f(val) for val in neighbor_values]

            # Best neighbor = minimum fitness
            best_neighbor_val = neighbor_values[np.argmin(neighbor_fitness)]

            # Update rule: average with best neighbor
            new_grid[i, j] = 0.5 * (grid[i, j] + best_neighbor_val)

    grid = new_grid  # update grid for next iteration

# --- Step 7: Output Results ---
print(f"Best solution found: x = {best_val:.4f}")
print(f"Minimum function value: f(x) = {best_fit:.4f}")